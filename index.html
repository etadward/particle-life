<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>互動物理實驗室 RWD (Responsive Physics Lab)</title>
    <style>
        /* --- 基礎設定 --- */
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #050505;
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            color: #eee;
            -webkit-tap-highlight-color: transparent; /* 移除手機點擊高亮 */
        }

        canvas {
            display: block;
            touch-action: none; /* 防止滑動 Canvas 時觸發瀏覽器滾動 */
        }

        /* --- 提示文字 --- */
        .hint {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: rgba(0, 255, 65, 0.2);
            font-size: 1.5rem;
            pointer-events: none;
            user-select: none;
            letter-spacing: 2px;
            text-align: center;
            z-index: 0;
            width: 80%;
            transition: top 0.3s ease;
        }

        /* --- 控制面板 (Desktop 預設樣式) --- */
        .control-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 300px;
            padding: 20px;
            border-radius: 12px;
            
            /* 磨砂玻璃效果 */
            background: rgba(20, 20, 20, 0.75);
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 30px rgba(0, 0, 0, 0.5);
            
            z-index: 10;
            transition: transform 0.3s cubic-bezier(0.4, 0.0, 0.2, 1), opacity 0.3s ease;
            max-height: 90vh;
            overflow-y: auto;
            scrollbar-width: thin;
        }

        /* 標題區域與摺疊按鈕 */
        .panel-header {
            font-size: 1.1rem;
            font-weight: 600;
            margin-bottom: 15px;
            color: #fff;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            padding-bottom: 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer; /* 讓標題可點擊以切換 */
        }

        .toggle-btn {
            font-size: 0.8rem;
            background: rgba(255, 255, 255, 0.1);
            border: none;
            color: #fff;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: background 0.2s;
        }
        .toggle-btn:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        /* 內容容器 (用於摺疊) */
        .panel-content {
            transition: max-height 0.3s ease, opacity 0.3s ease;
            max-height: 500px; /* 足夠放下所有控制項 */
            opacity: 1;
            overflow: hidden;
        }

        .panel-collapsed .panel-content {
            max-height: 0;
            opacity: 0;
            margin: 0;
            padding: 0;
        }

        .control-group {
            margin-bottom: 18px; /* 增加間距方便觸控 */
        }

        .control-label {
            display: flex;
            justify-content: space-between;
            font-size: 0.85rem;
            color: #ccc;
            margin-bottom: 8px;
        }

        .value-display {
            color: #00ff41;
            font-family: monospace;
        }

        /* --- 自訂滑桿樣式 (加大觸控區) --- */
        input[type=range] {
            -webkit-appearance: none;
            width: 100%;
            background: transparent;
            height: 20px; /* 加高軌道感應區 */
            margin: 5px 0;
        }

        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 20px;
            width: 20px;
            border-radius: 50%;
            background: #00ff41;
            cursor: pointer;
            margin-top: -8px; /* 調整位置 */
            box-shadow: 0 0 10px rgba(0, 255, 65, 0.5);
            border: 2px solid #fff;
        }

        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
        }

        /* --- 自訂顏色選擇器 --- */
        input[type=color] {
            -webkit-appearance: none;
            border: none;
            width: 100%;
            height: 40px;
            cursor: pointer;
            background: none;
            padding: 0;
        }
        input[type=color]::-webkit-color-swatch-wrapper { padding: 0; }
        input[type=color]::-webkit-color-swatch {
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 8px;
        }

        /* --- Checkbox 樣式 --- */
        .checkbox-wrapper {
            display: flex;
            align-items: center;
            cursor: pointer;
            margin-bottom: 15px;
            padding: 5px 0; /* 增加點擊區 */
        }
        .checkbox-wrapper input {
            display: none;
        }
        .custom-checkbox {
            width: 22px;
            height: 22px;
            border: 2px solid #00ff41;
            border-radius: 6px;
            margin-right: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s;
            flex-shrink: 0;
        }
        .checkbox-wrapper input:checked + .custom-checkbox {
            background: #00ff41;
        }
        .checkbox-wrapper input:checked + .custom-checkbox::after {
            content: '✔';
            font-size: 14px;
            color: #000;
            font-weight: bold;
        }
        .mode-label {
            color: #00ff41;
            font-weight: bold;
            font-size: 0.95rem;
        }

        /* --- 統計數據 --- */
        .stats {
            margin-top: 20px;
            padding-top: 15px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            font-size: 0.8rem;
            color: #888;
        }

        /* --- RWD 手機版 + 自動收合特效 --- */
        @media screen and (max-width: 768px) {
            .hint {
                top: 30%; /* 避免被底部面板擋住 */
                font-size: 1.2rem;
            }

            .control-panel {
                /* 1. 定位與外觀基礎 */
                position: fixed !important;
                bottom: 0 !important;
                left: 0 !important;
                right: 0 !important;
                top: auto !important;
                width: 100% !important;
                max-width: none !important;
                
                background: rgba(10, 10, 10, 0.95) !important; /* 背景深一點 */
                backdrop-filter: blur(12px);
                border-radius: 20px 20px 0 0 !important;
                padding: 0 20px !important; 
                z-index: 1000;
                cursor: pointer; /* 讓點擊在 iOS 上更明確 */

                /* 2. 收合邏輯 (核心魔法) */
                /* [修正] 移除強制 height，改用 max-height 控制開合 */
                /* height: 50px !important;  <-- 原本導致無法展開的主因 */
                max-height: 50px !important;  
                overflow: hidden !important; 
                transition: max-height 0.4s cubic-bezier(0.25, 0.8, 0.25, 1), background 0.3s; 
                
                /* 3. 排版 */
                display: flex;
                flex-direction: column;
                justify-content: flex-start;
                gap: 15px;
                transform: none !important; /* 確保不被 JS 狀態影響 */
            }

            /* 隱藏原本的 Desktop 標題列，改用 CSS 生成 */
            .panel-header {
                display: none !important;
            }

            /* 確保內容區域總是顯示 (由父層 height 控制裁切) */
            .panel-content {
                max-height: none !important;
                opacity: 1 !important;
                margin: 0 !important;
                padding-bottom: 30px; /* 底部多一點留白 */
                
                /* [修復] 收合時禁用內容的指針事件，防止點擊到隱藏的按鈕 */
                pointer-events: none; 
                transition: opacity 0.3s ease;
            }

            /* 當有 .mobile-expanded class 時 -> 展開 */
            .control-panel.mobile-expanded {
                max-height: 480px !important; /* 展開到足夠的高度 */
                background: rgba(10, 10, 10, 0.98) !important;
            }

            /* 展開時，恢復內容的指針事件 */
            .control-panel.mobile-expanded .panel-content {
                pointer-events: auto;
            }

            /* 4. 憑空產生的標題文字 */
            .control-panel::before {
                content: "物理控制台 ▴"; 
                color: #00ff41; /* 霓虹綠 */
                font-family: 'Segoe UI', sans-serif;
                font-weight: bold;
                font-size: 16px;
                text-align: center;
                
                display: block;
                width: 100%;
                margin-top: 15px;     
                margin-bottom: 5px;
                flex-shrink: 0;
                opacity: 0.9;
                pointer-events: none; /* 標題不攔截事件，讓事件傳遞給 panel */
            }
            
            /* 展開時改變箭頭 */
            .control-panel.mobile-expanded::before {
                content: "物理控制台 ▾";
                color: #fff;
            }

            /* 優化滑桿觸控區 */
            input[type=range] {
                margin-top: 5px;
                height: 30px;
            }
        }
    </style>
</head>
<body>

    <div class="hint">切換模式 / 點擊畫面 / 拖曳滑鼠</div>

    <!-- 懸浮控制面板 -->
    <div class="control-panel" id="panel">
        <div class="panel-header" id="panel-toggle">
            <span>物理控制台</span>
            <button class="toggle-btn" aria-label="Toggle Menu">
                <span id="toggle-icon">−</span>
            </button>
        </div>

        <div class="panel-content">
            <!-- 模式切換 -->
            <label class="checkbox-wrapper">
                <input type="checkbox" id="ctrl-flocking">
                <div class="custom-checkbox"></div>
                <span class="mode-label">開啟群體模式 (Flocking)</span>
            </label>

            <div class="control-group">
                <div class="control-label">
                    <span>重力 (Gravity)</span>
                    <span id="val-gravity" class="value-display">0.60</span>
                </div>
                <input type="range" id="ctrl-gravity" min="0" max="1.5" step="0.05" value="0.6">
            </div>

            <div class="control-group">
                <div class="control-label">
                    <span>消失速度 (Fade Rate)</span>
                    <span id="val-fade" class="value-display">0.050</span>
                </div>
                <input type="range" id="ctrl-fade" min="0.005" max="0.2" step="0.005" value="0.05">
            </div>

            <div class="control-group">
                <div class="control-label">
                    <span>粒子顏色</span>
                </div>
                <input type="color" id="ctrl-color" value="#00ff41">
            </div>

            <div class="stats">
                活躍粒子數: <span id="particle-count" class="value-display">0</span> / <span id="max-limit">∞</span>
            </div>
        </div>
    </div>

    <canvas id="canvas"></canvas>

    <script>
        /**
         * 互動物理實驗室 RWD 版
         */
        
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // UI 元素
        const panel = document.getElementById('panel');
        const panelToggle = document.getElementById('panel-toggle');
        const toggleIcon = document.getElementById('toggle-icon');
        
        const ctrlFlocking = document.getElementById('ctrl-flocking');
        const ctrlGravity = document.getElementById('ctrl-gravity');
        const ctrlFade = document.getElementById('ctrl-fade');
        const ctrlColor = document.getElementById('ctrl-color');
        const valGravity = document.getElementById('val-gravity');
        const valFade = document.getElementById('val-fade');
        const particleCountDisplay = document.getElementById('particle-count');
        const maxLimitDisplay = document.getElementById('max-limit');

        // 設定畫布尺寸
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resizeCanvas();

        // 全域配置
        const config = {
            isFlocking: false,
            gravity: parseFloat(ctrlGravity.value),
            fadeRate: parseFloat(ctrlFade.value),
            color: ctrlColor.value,
            friction: 0.75, 
            maxParticlesFlocking: 150, // 手機效能考量，稍微降低上限
            mouse: { x: -1000, y: -1000 }
        };

        // 偵測是否為移動裝置 (簡單判斷)
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        if (isMobile) {
            config.maxParticlesFlocking = 100; // 手機版更嚴格的限制
        }

        let particles = [];

        function randomIntFromRange(min, max) {
            return Math.floor(Math.random() * (max - min + 1) + min);
        }

        const Vector = {
            dist: (p1, p2) => Math.sqrt((p1.x - p2.x)**2 + (p1.y - p2.y)**2),
            normalize: (dx, dy) => {
                const m = Math.sqrt(dx*dx + dy*dy);
                if (m > 0) return { x: dx/m, y: dy/m };
                return { x: 0, y: 0 };
            }
        };

        /**
         * 粒子類別
         */
        class Particle {
            constructor(x, y, radius, color, velocityMultiplier = 1) {
                this.x = x;
                this.y = y;
                this.radius = radius;
                this.originalRadius = radius;
                this.color = color;
                this.alpha = 1;
                
                this.dx = randomIntFromRange(-5, 5) * velocityMultiplier;
                this.dy = randomIntFromRange(-3, 3) * velocityMultiplier; 
                
                this.maxSpeed = 4;
                this.maxForce = 0.1;
            }

            draw() {
                ctx.save();
                ctx.globalAlpha = this.alpha;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2, false);
                ctx.shadowBlur = 15; 
                ctx.shadowColor = this.color;
                ctx.fillStyle = this.color;
                ctx.fill();
                ctx.closePath();
                ctx.restore();
            }

            applyBehaviors(particles) {
                let separateForce = this.separate(particles);
                let alignForce = this.align(particles);
                let cohesionForce = this.cohesion(particles);
                let fleeForce = this.flee(config.mouse);

                separateForce.x *= 1.5; separateForce.y *= 1.5;
                alignForce.x *= 1.0;    alignForce.y *= 1.0;
                cohesionForce.x *= 1.0; cohesionForce.y *= 1.0;
                fleeForce.x *= 5.0;     fleeForce.y *= 5.0;

                this.dx += separateForce.x + alignForce.x + cohesionForce.x + fleeForce.x;
                this.dy += separateForce.y + alignForce.y + cohesionForce.y + fleeForce.y;

                const speed = Math.sqrt(this.dx*this.dx + this.dy*this.dy);
                if (speed > this.maxSpeed) {
                    this.dx = (this.dx / speed) * this.maxSpeed;
                    this.dy = (this.dy / speed) * this.maxSpeed;
                }
            }

            separate(particles) {
                let desiredSeparation = 25;
                let steer = { x: 0, y: 0 };
                let count = 0;
                for (let other of particles) {
                    let d = Vector.dist(this, other);
                    if ((d > 0) && (d < desiredSeparation)) {
                        let diff = { x: this.x - other.x, y: this.y - other.y };
                        const distMag = Math.sqrt(diff.x*diff.x + diff.y*diff.y);
                        if(distMag > 0) {
                            diff.x /= distMag; diff.y /= distMag;
                        }
                        steer.x += diff.x;
                        steer.y += diff.y;
                        count++;
                    }
                }
                if (count > 0) {
                    steer.x /= count; steer.y /= count;
                }
                return steer;
            }

            align(particles) {
                let neighborDist = 50;
                let sum = { x: 0, y: 0 };
                let count = 0;
                for (let other of particles) {
                    let d = Vector.dist(this, other);
                    if ((d > 0) && (d < neighborDist)) {
                        sum.x += other.dx;
                        sum.y += other.dy;
                        count++;
                    }
                }
                if (count > 0) {
                    sum.x /= count; sum.y /= count;
                    const mag = Math.sqrt(sum.x*sum.x + sum.y*sum.y);
                    if (mag > 0) {
                         sum.x = (sum.x/mag) * this.maxSpeed;
                         sum.y = (sum.y/mag) * this.maxSpeed;
                    }
                    let steer = { x: sum.x - this.dx, y: sum.y - this.dy };
                    return this.limitForce(steer);
                }
                return { x: 0, y: 0 };
            }

            cohesion(particles) {
                let neighborDist = 50;
                let sum = { x: 0, y: 0 };
                let count = 0;
                for (let other of particles) {
                    let d = Vector.dist(this, other);
                    if ((d > 0) && (d < neighborDist)) {
                        sum.x += other.x;
                        sum.y += other.y;
                        count++;
                    }
                }
                if (count > 0) {
                    sum.x /= count; sum.y /= count;
                    return this.seek(sum);
                }
                return { x: 0, y: 0 };
            }

            seek(target) {
                let desired = { x: target.x - this.x, y: target.y - this.y };
                const d = Math.sqrt(desired.x*desired.x + desired.y*desired.y);
                if(d > 0) {
                    desired.x = (desired.x/d) * this.maxSpeed;
                    desired.y = (desired.y/d) * this.maxSpeed;
                }
                let steer = { x: desired.x - this.dx, y: desired.y - this.dy };
                return this.limitForce(steer);
            }

            flee(target) {
                let desired = { x: target.x - this.x, y: target.y - this.y };
                const d = Math.sqrt(desired.x*desired.x + desired.y*desired.y);
                if (d < 100) {
                    desired.x = (desired.x/d) * this.maxSpeed;
                    desired.y = (desired.y/d) * this.maxSpeed;
                    desired.x *= -1;
                    desired.y *= -1;
                    let steer = { x: desired.x - this.dx, y: desired.y - this.dy };
                    return this.limitForce(steer);
                }
                return { x: 0, y: 0 };
            }

            limitForce(force) {
                const mag = Math.sqrt(force.x*force.x + force.y*force.y);
                if (mag > this.maxForce) {
                    force.x = (force.x / mag) * this.maxForce;
                    force.y = (force.y / mag) * this.maxForce;
                }
                return force;
            }

            update() {
                if (config.isFlocking) {
                    this.applyBehaviors(particles);
                    this.x += this.dx;
                    this.y += this.dy;

                    if (this.x < -this.radius) this.x = canvas.width + this.radius;
                    if (this.y < -this.radius) this.y = canvas.height + this.radius;
                    if (this.x > canvas.width + this.radius) this.x = -this.radius;
                    if (this.y > canvas.height + this.radius) this.y = -this.radius;

                    if (this.radius < this.originalRadius) {
                        this.radius += 0.05;
                    }
                } else {
                    if (this.y + this.radius + this.dy > canvas.height) {
                        this.dy = -this.dy * config.friction;
                        this.dx = this.dx * 0.9;
                    } else {
                        this.dy += config.gravity;
                    }

                    if (this.x + this.radius + this.dx > canvas.width || this.x - this.radius <= 0) {
                        this.dx = -this.dx * 0.5;
                    }

                    this.x += this.dx;
                    this.y += this.dy;

                    if (this.radius > 0.1) {
                        this.radius -= config.fadeRate;
                        if (this.radius < 0) this.radius = 0;
                    }
                }
                this.draw();
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            ctx.fillStyle = 'rgba(5, 5, 5, 0.3)'; 
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            if (config.isFlocking && particles.length < config.maxParticlesFlocking) {
                spawnParticles(Math.random() * canvas.width, Math.random() * canvas.height, 1);
            }

            for (let i = 0; i < particles.length; i++) {
                particles[i].update();
                
                let shouldRemove = false;
                if (config.isFlocking) {
                    if (particles.length > config.maxParticlesFlocking) shouldRemove = true; 
                } else {
                    if (particles[i].radius <= 0.1) shouldRemove = true;
                }

                if (shouldRemove) {
                    particles.splice(i, 1);
                    i--;
                }
            }
            particleCountDisplay.textContent = particles.length;
        }

        function spawnParticles(x, y, count, isExplosion = false) {
            if (config.isFlocking && particles.length >= config.maxParticlesFlocking) return;

            for(let i = 0; i < count; i++) {
                if (config.isFlocking && particles.length >= config.maxParticlesFlocking) break;
                const radius = randomIntFromRange(3, 6);
                const color = config.color;
                const velocityMult = isExplosion ? (Math.random() * 3 + 1) : 1;
                particles.push(new Particle(x, y, radius, color, velocityMult));
            }
        }

        function initEvents() {
            // 滑鼠/觸控事件處理核心
            const handleInput = (x, y, isClick = false) => {
                config.mouse.x = x;
                config.mouse.y = y;
                
                if (isClick) {
                    if (!config.isFlocking) spawnParticles(x, y, 60, true);
                } else {
                    if (!config.isFlocking) spawnParticles(x, y, 3);
                }
            };

            // 1. 滑鼠移動事件 (桌面版)
            window.addEventListener('mousemove', e => {
                // 只有當滑鼠不在面板上時才觸發互動
                if (!e.target.closest('.control-panel')) {
                    handleInput(e.clientX, e.clientY);
                }
            });

            // 2. 觸控事件優化 (手機/平板版)
            const handleTouch = (e) => {
                // 防止在 Canvas 上滑動時觸發瀏覽器的下拉刷新或捲動
                if(e.cancelable) e.preventDefault(); 
                
                const touch = e.touches[0];
                handleInput(touch.clientX, touch.clientY);
            };

            // 新增 touchstart: 手指一接觸螢幕就有反應
            canvas.addEventListener('touchstart', handleTouch, { passive: false });
            // touchmove: 手指滑動時持續更新位置
            canvas.addEventListener('touchmove', handleTouch, { passive: false });

            // 3. 點擊/爆炸事件
            canvas.addEventListener('mousedown', e => handleInput(e.clientX, e.clientY, true));
            
            // 處理面板 UI 事件
            ctrlFlocking.addEventListener('change', (e) => {
                config.isFlocking = e.target.checked;
                if (config.isFlocking) {
                    maxLimitDisplay.textContent = config.maxParticlesFlocking;
                    if (particles.length > config.maxParticlesFlocking) {
                        particles = particles.slice(0, config.maxParticlesFlocking);
                    }
                    particles.forEach(p => {
                        if (p.radius < 2) p.radius = 3;
                    });
                } else {
                    maxLimitDisplay.textContent = "∞";
                }
            });

            ctrlGravity.addEventListener('input', (e) => {
                config.gravity = parseFloat(e.target.value);
                valGravity.textContent = config.gravity.toFixed(2);
            });

            ctrlFade.addEventListener('input', (e) => {
                config.fadeRate = parseFloat(e.target.value);
                valFade.textContent = config.fadeRate.toFixed(3);
            });

            ctrlColor.addEventListener('input', (e) => {
                config.color = e.target.value;
            });

            window.addEventListener('resize', resizeCanvas);

            // 面板摺疊邏輯 (Desktop 保留點擊摺疊，手機版由 JS click 事件處理)
            panelToggle.addEventListener('click', () => {
                // 在手機版上隱藏了 toggle-btn，所以這段只會對 Desktop 生效
                panel.classList.toggle('panel-collapsed');
                const isCollapsed = panel.classList.contains('panel-collapsed');
                toggleIcon.textContent = isCollapsed ? '+' : '−';
            });

            // 手機版專屬：點擊面板本身來切換展開狀態
            panel.addEventListener('click', (e) => {
                // 只有在手機版寬度下才執行
                if (window.innerWidth <= 768) {
                    const isCollapsed = !panel.classList.contains('mobile-expanded');
                    
                    if (isCollapsed) {
                        // 如果目前是收合的，任何點擊都視為展開（因為內容是隱藏的）
                        panel.classList.add('mobile-expanded');
                    } else {
                        // 如果已經展開，要判斷是否點擊到控制項
                        if (e.target.tagName === 'INPUT' || 
                            e.target.closest('.checkbox-wrapper') || 
                            e.target.tagName === 'LABEL') {
                            return; // 讓使用者操作控制項
                        }
                        // 點擊空白處或標題則收合
                        panel.classList.remove('mobile-expanded');
                    }
                }
            });
        }

        initEvents();
        animate();

    </script>
</body>
</html>